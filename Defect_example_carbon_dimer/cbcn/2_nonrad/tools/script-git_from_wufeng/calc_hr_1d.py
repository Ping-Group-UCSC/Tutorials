#!/usr/bin/env python
#This script calculate HR factor from one phonons 
#Output format :

#
#case = initph or finalph ( calculated from initial or final structure)
#["%s-Sk" % case]  : all S_k for each phonon mode
#["%s-S" % case] : summation of S_k
#["%s-IndexLargeS" % case] : band index (1-based) sorted in descending order

import sys
import os
import yaml
import numpy as np
from constant import *
from math import sqrt
from numpy.linalg import norm
from libphonon import plot_phonon_mode_multi, plot_phonon_mode
from io_package import read_cell_and_pos_auto
from chem_utils import f_Element_Symbol_to_Mass
np.seterr(all="log")

def read_yaml(filename):
    with open(filename, 'r') as f:
        d = yaml.load(f.read())
    return d

def saveinput():
    with open(file_input, 'w') as f:
        yaml.dump(dinput, f, default_flow_style=False, width=200)

def save():
    with open(file_store, 'w') as f:
        yaml.dump(data, f, default_flow_style=False, width=200)

    with open(file_store2, 'w') as f:
        yaml.dump(data2, f, default_flow_style=False, width=200)

def is_option_set(term):
    '''
    Check if an options is set
    This is just a rough test with string
    '''
    return not term.startswith("The ") and not term.strip() == ""

file_input = "input.yaml"
file_store = "output.yaml"
file_store2 = "detail.yaml"

if (not os.path.exists(file_input)):
    dinput = yaml.load('''
title: HR 
pwx_prefix_init_relax : The folder name and prefix of relaxation or scf with initial state geometry
pwx_prefix_final_relax : The folder name and prefix of relaxation or scf with final state geometry
phonopy_folder : The folder name of phonopy calculation
phx_filename_phonon_dynmat:  The filename of dynamt file generated by ph.x
phx_filename_phonon_mold: The filename of .mold file generated by ph.x
''')
else:
    dinput = read_yaml(file_input)

if ("The " in dinput["pwx_prefix_init_relax"]):
    print("Please modify %s according to instruction inside" % file_input)
    saveinput()
    sys.exit(1)

if (not os.path.exists(file_store)):
    data = {}
    data2 = {}
else:
    data = read_yaml(file_store)
    data2 = read_yaml(file_store2)


#Compuate Huang-Rhys factor for each mode
if (not "data-1D-dQ2-Bohr2" in data):
#Load structures
#Note all units in Bohr
    (vecRi, list_atom_init), package = read_cell_and_pos_auto(dinput["pwx_prefix_init_relax"])
    (vecRf, list_atom_final), package = read_cell_and_pos_auto(dinput["pwx_prefix_final_relax"])
#Convert to Bohr
    vecRi *= Ang2Bohr
    vecRf *= Ang2Bohr

#This is to read the shared information (mass and species)
    list_atom_common = list_atom_init

#Add mass information
#Note without phonon calculation this must be read
    for atom in list_atom_common:
        atom["mass"] = f_Element_Symbol_to_Mass(atom["species"]) 

    print(vecRi, vecRf)

    if  (np.abs(vecRi -vecRf) > 1e-5).any():
        raise ValueError("Lattice parameter of initial and final structure not consistent")
    vecR = vecRi

#Compute eq(6) m^1/2 (R-R)
    list_diffR = []
    for i in range(len(list_atom_common)):
#       v1 = np.dot(vecR, list_atom_init[i]["pos"] - list_atom_final[i]["pos"])  * list_atom_init[i]["mass"]
        v1 = np.dot(vecR, list_atom_init[i]["pos"] - list_atom_final[i]["pos"])
        list_diffR.append(v1)
            
#Save 1D-effective
    list_dR2 = [np.dot(vecR, x["pos"] - x2["pos"]) for x, x2 in zip(list_atom_init, list_atom_final)]
    data2["1D-dR-Bohr"] = np.array(list_dR2).flatten().tolist()
    list_dQ2 = [np.dot(x, x) * list_atom_common[i]["mass"] for i, x in enumerate(list_dR2)]
    data["1D-dQ2-Bohr2"] = float(sum(list_dQ2))

#Plot the phonon between two structures
    plot_phonon_mode("phonon-1dcoord", vecR*Bohr2Ang, list_atom_final, np.asarray([x["pos"] - x2["pos"] for x, x2 in zip(list_atom_init, list_atom_final)]), unit_pos="crystal", unit_eigen="crystal", scale=4)


save()


